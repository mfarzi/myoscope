classdef math  
    % MATH 
    %
    %   math is a static class encapsulating constant variables and mehtods
    %   used for tensorial operations. This class is used with compartment
    %   models.
    %
    %
    %   methods (public):
    %       fit             - fit model parameters to measured signals
    %       fitMultiRun     - run the optimisation using different 
    %                         initial points selected randomly.
    %       synthesize      - synthesize attenuation signals
    %       getCost         - return the Root Mean Square (RMS) error of
    %                         the fitted model
    %       getParams       - return the model parameters in a column
    %                         vector
    %       getParamsNum    - return the number of model parameters
    %       getFixedParams  - return a logical column vector stating if a
    %                         parameter is fixed (true) or not (false).
    %
    %
    %   See also: compartment
    %
    % Mohsen Farzi
    % Email: m.farzi@leeds.ac.uk
    
    properties (Constant=true)
        % the gyromagnetic Ratio (copied from camino source codes)
        GAMMA = 2.6751525e8; % rad s-1 T-1
        
        % 159 first roots from the equation J'1(x)=0 with 12 significant
        % digits precision
        % J'1 is the derivative of the first order bessel function
        % J'n(x) = n/x*Jn(x)-Jn+1(x)
      
        Jp1ROOTSb = ...
          [1.84118378134 5.33144277353 8.53631636635,...
           11.7060049026 14.8635886339 18.0155278627,...
           21.1643698592 24.3113268572 27.4570505711,...
           30.6019229727 33.7461828987 36.8899874092,...
           40.0334440534 43.1766289654 46.3195975612,...
           49.4623911397 52.6050411116 55.7475717923,...
           58.8900022992 62.0323478707 65.1746208025,...
           68.3168311260 71.4589871059 74.6010956135,...
           77.7431624082 80.8851923539 84.0271895863,...
           87.1691576445 90.3110995749 93.4530180138,...
           96.5949152543 99.7367933006 102.878653912,...
           106.020498638 109.162328852 112.304145772,...
           115.445950483 118.587743956 121.729527062,...
           124.871300582 128.013065224 131.154821625,...
           134.296570363 137.438311965 140.580046908,...
           143.721775630 146.863498529 150.005215973,...
           153.146928296 156.288635807 159.430338791,...
           162.572037511 165.713732208 168.855423108,...
           171.997110419 175.138794334 178.280475031,...
           181.422152680 184.563827434 187.705499440]';
       
        Jp1ROOTS = ...
          [1.84118378134 5.33144277353 8.53631636635,...
           11.7060049026 14.8635886339 18.0155278627,...
           21.1643698592 24.3113268572 27.4570505711,...
           30.6019229727 33.7461828987 36.8899874092,...
           40.0334440534 43.1766289654 46.3195975612,...
           49.4623911397 52.6050411116 55.7475717923,...
           58.8900022992 62.0323478707 65.1746208025,...
           68.3168311260 71.4589871059 74.6010956135,...
           77.7431624082 80.8851923539 84.0271895863,...
           87.1691576445 90.3110995749 93.4530180138,...
           96.5949152543 99.7367933006 102.878653912,...
           106.020498638 109.162328852 112.304145772,...
           115.445950483 118.587743956 121.729527062,...
           124.871300582 128.013065224 131.154821625,...
           134.296570363 137.438311965 140.580046908,...
           143.721775630 146.863498529 150.005215973,...
           153.146928296 156.288635807 159.430338791,...
           162.572037511 165.713732208 168.855423108,...
           171.997110419 175.138794334 178.280475031,...
           181.422152680 184.563827434 187.705499440,...
           190.847168834 193.988835741 197.130500282,...
           200.272162567 203.413822702 206.555480783,...
           209.697136904 212.838791151 215.980443606,...
           219.122094346 222.263743445 225.405390969,...
           228.547036985 231.688681554 234.830324734,...
           237.971966579 241.113607143 244.255246474,...
           247.396884620 250.538521624 253.680157530,...
           256.821792378 259.963426206 263.105059051,...
           266.246690947 269.388321928 272.529952025,...
           275.671581269 278.813209688 281.954837310,...
           285.096464161 288.238090267 291.379715652,...
           294.521340338 297.662964348 300.804587703,...
           303.946210423 307.087832528 310.229454037,...
           313.371074967 316.512695336 319.654315160,...
           322.795934455 325.937553236 329.079171519,...
           332.220789317 335.362406644 338.504023512,...
           341.645639936 344.787255926 347.928871495,...
           351.070486653 354.212101413 357.353715784,...
           360.495329776 363.636943399 366.778556664,...
           369.920169578 373.061782151 376.203394391,...
           379.345006307 382.486617906 385.628229197,...
           388.769840187 391.911450882 395.053061291,...
           398.194671419 401.336281274 404.477890862,...
           407.619500188 410.761109260 413.902718082,...
           417.044326661 420.185935001 423.327543109,...
           426.469150989 429.610758647 432.752366086,...
           435.893973312 439.035580330 442.177187144,...
           445.318793758 448.460400176 451.602006403,...
           454.743612442 457.885218298 461.026823973,...
           464.168429473 467.310034799 470.451639957,...
           473.593244948 476.734849777 479.876454447,...
           483.018058960 486.159663320 489.301267529,...
           492.442871591 495.584475509 498.726079284]';
    end
    
    methods (Static)
        leb_tmp = getLebedevSphere(degree);
        U = getUnitFrame(theta, phi, alpha);
        u1 = get_u1(theta, phi, ~);
        gU1_gTheta = get_gU1_gTheta(theta, phi, ~)
        gU1_gPhi = get_gU1_gPhi(theta, phi, ~)
        [theta, phi, alpha] = getOrientationAngles(U);
        [gU1, gU2, gU3] = getOrientationJacobian(theta, phi, alpha);
        state = isOrthonormal(U);
        [pts, weights] = sampleSphere(method, params);
        r = ricernd(v, s)
        [theta, phi, alpha] = simplifyOrientationAngles(theta, phi, alpha);
        
        function rotateAxis(obj)
            % rotateAxis remove the ambiguity in estimation of parameters
            % theta, phi, and alpha by rotating the cooriante system of the
            % eigen vectors appropriately.
            % 
            % The orthonormal coordiante system V = [v1, v2, v3] should 
            % rotate such that the eigne vectors v1, v2, and v3 are 
            % associated with the eigen values in a descending order.
            %
            % More over, the direction of v1 or -v1 is selected such that
            % the angle theta is always in range [0, pi/2].
            % 
            % Finally, the direction v2 or -v2 is selected such that the
            % angle alpha is always between [0, phi].
            %
            % see also: getUnitFrame, getEulerAngles
            
            % read params
            p = obj.params;
            diffPar     = p(2);   % diffusivity [s/m^2]
            diffPerp1   = p(3);   % diffusivity [s/m^2]
            diffPerp2   = p(4);   % diffusivity [s/m^2]
            theta       = p(5);   % elevation angle
            phi         = p(6);   % azimuth angel
            alpha       = p(7);   % angele beween v1_zrot and v2
            
            V = math.getUnitFrame(theta, phi, alpha);
            
            % sort the eigen values in descending order
            eigVal = [diffPar; diffPerp1; diffPerp2];
            [eigVal, sortID] = sort(eigVal, 'descend');
            
            diffPar   = eigVal(1);
            diffPerp1 = eigVal(2);
            diffPerp2 = eigVal(3);
            
            V = V(:,sortID);
            % make sure V is still orthogonal following the permutation
            if uint8(norm(cross(V(:,1), V(:,2))-V(:,3))) ~= 0
                V(:,3) = -V(:,3);
            end
            [theta, phi, alpha] = math.getEulerAngles(V);
            
            % make sure theta < pi/2
            if obj.theta>pi/2
                theta = pi - theta;
                phi = pi + phi;
                alpha = -alpha;
            end

            phi = mod(phi, 2*pi);
            
            % make sure alpha is in rage [0, pi]
            alpha = mod(alpha, pi);
            
            obj.params(2:end) = [diffPar; diffPerp1; diffPerp2; theta; ...
                                 phi; alpha];
        end % of rotateAxis
        
        function adc = getADC(obj)
            % compute Apparate Diffusion Coefficient
            adc = (obj.diffPar + obj.diffPerp1 + obj.diffPerp2)/3;
        end
        
        function fa = getFA(obj)
            % Fractional anisotropy
            lambda = [obj.diffPar, obj.diffPerp1, obj.diffPerp2];
            lambda_hat = mean(lambda);
            fa = sqrt(3/2)*norm(lambda-lambda_hat)/norm(lambda);
        end
                    
        function DT = getDT(obj)
            V = obj.getEigenVec();
            D = diag([obj.diffPar; obj.diffPerp1; obj.diffPerp2]);
            DT = V*D*V';
        end
        
        function V = getEigenVec(obj)
            V = getUnitFrame(obj.theta, obj.phi, obj.alpha);
        end
        
        function g = J1p(x)
            g = besselj(1,x)./x-besselj(2,x);
        end
        
        function R = findJ1pRoots()
            x = 0.5:0.1:500;
            y = math.J1p(x);
            R = [];
            for i=1:length(y)-1
                if y(i)*y(i+1)<0
                    r = fzero(@math.J1p, [x(i), x(i+1)]);
                    R = [R; r];
                end
            end
        end        
    end%of method
end